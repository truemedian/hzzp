<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>crypto/Certificate.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1">buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2">index: <span class="tok-type">u32</span>,</span>
<span class="line" id="L3"></span>
<span class="line" id="L4"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Bundle = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Certificate/Bundle.zig&quot;</span>);</span>
<span class="line" id="L5"></span>
<span class="line" id="L6"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Algorithm = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L7">    sha1WithRSAEncryption,</span>
<span class="line" id="L8">    sha224WithRSAEncryption,</span>
<span class="line" id="L9">    sha256WithRSAEncryption,</span>
<span class="line" id="L10">    sha384WithRSAEncryption,</span>
<span class="line" id="L11">    sha512WithRSAEncryption,</span>
<span class="line" id="L12">    ecdsa_with_SHA224,</span>
<span class="line" id="L13">    ecdsa_with_SHA256,</span>
<span class="line" id="L14">    ecdsa_with_SHA384,</span>
<span class="line" id="L15">    ecdsa_with_SHA512,</span>
<span class="line" id="L16"></span>
<span class="line" id="L17">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> map = std.ComptimeStringMap(Algorithm, .{</span>
<span class="line" id="L18">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0xF7</span>, <span class="tok-number">0x0D</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x05</span> }, .sha1WithRSAEncryption },</span>
<span class="line" id="L19">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0xF7</span>, <span class="tok-number">0x0D</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x0B</span> }, .sha256WithRSAEncryption },</span>
<span class="line" id="L20">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0xF7</span>, <span class="tok-number">0x0D</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x0C</span> }, .sha384WithRSAEncryption },</span>
<span class="line" id="L21">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0xF7</span>, <span class="tok-number">0x0D</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x0D</span> }, .sha512WithRSAEncryption },</span>
<span class="line" id="L22">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0xF7</span>, <span class="tok-number">0x0D</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x0E</span> }, .sha224WithRSAEncryption },</span>
<span class="line" id="L23">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0xCE</span>, <span class="tok-number">0x3D</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x01</span> }, .ecdsa_with_SHA224 },</span>
<span class="line" id="L24">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0xCE</span>, <span class="tok-number">0x3D</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x02</span> }, .ecdsa_with_SHA256 },</span>
<span class="line" id="L25">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0xCE</span>, <span class="tok-number">0x3D</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x03</span> }, .ecdsa_with_SHA384 },</span>
<span class="line" id="L26">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0xCE</span>, <span class="tok-number">0x3D</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x04</span> }, .ecdsa_with_SHA512 },</span>
<span class="line" id="L27">    });</span>
<span class="line" id="L28"></span>
<span class="line" id="L29">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Hash</span>(<span class="tok-kw">comptime</span> algorithm: Algorithm) <span class="tok-type">type</span> {</span>
<span class="line" id="L30">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (algorithm) {</span>
<span class="line" id="L31">            .sha1WithRSAEncryption =&gt; crypto.hash.Sha1,</span>
<span class="line" id="L32">            .ecdsa_with_SHA224, .sha224WithRSAEncryption =&gt; crypto.hash.sha2.Sha224,</span>
<span class="line" id="L33">            .ecdsa_with_SHA256, .sha256WithRSAEncryption =&gt; crypto.hash.sha2.Sha256,</span>
<span class="line" id="L34">            .ecdsa_with_SHA384, .sha384WithRSAEncryption =&gt; crypto.hash.sha2.Sha384,</span>
<span class="line" id="L35">            .ecdsa_with_SHA512, .sha512WithRSAEncryption =&gt; crypto.hash.sha2.Sha512,</span>
<span class="line" id="L36">        };</span>
<span class="line" id="L37">    }</span>
<span class="line" id="L38">};</span>
<span class="line" id="L39"></span>
<span class="line" id="L40"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AlgorithmCategory = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L41">    rsaEncryption,</span>
<span class="line" id="L42">    X9_62_id_ecPublicKey,</span>
<span class="line" id="L43"></span>
<span class="line" id="L44">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> map = std.ComptimeStringMap(AlgorithmCategory, .{</span>
<span class="line" id="L45">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0xF7</span>, <span class="tok-number">0x0D</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x01</span> }, .rsaEncryption },</span>
<span class="line" id="L46">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0xCE</span>, <span class="tok-number">0x3D</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0x01</span> }, .X9_62_id_ecPublicKey },</span>
<span class="line" id="L47">    });</span>
<span class="line" id="L48">};</span>
<span class="line" id="L49"></span>
<span class="line" id="L50"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Attribute = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L51">    commonName,</span>
<span class="line" id="L52">    serialNumber,</span>
<span class="line" id="L53">    countryName,</span>
<span class="line" id="L54">    localityName,</span>
<span class="line" id="L55">    stateOrProvinceName,</span>
<span class="line" id="L56">    organizationName,</span>
<span class="line" id="L57">    organizationalUnitName,</span>
<span class="line" id="L58">    organizationIdentifier,</span>
<span class="line" id="L59">    pkcs9_emailAddress,</span>
<span class="line" id="L60"></span>
<span class="line" id="L61">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> map = std.ComptimeStringMap(Attribute, .{</span>
<span class="line" id="L62">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x03</span> }, .commonName },</span>
<span class="line" id="L63">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x05</span> }, .serialNumber },</span>
<span class="line" id="L64">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x06</span> }, .countryName },</span>
<span class="line" id="L65">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x07</span> }, .localityName },</span>
<span class="line" id="L66">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x08</span> }, .stateOrProvinceName },</span>
<span class="line" id="L67">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x0A</span> }, .organizationName },</span>
<span class="line" id="L68">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x0B</span> }, .organizationalUnitName },</span>
<span class="line" id="L69">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x61</span> }, .organizationIdentifier },</span>
<span class="line" id="L70">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0xF7</span>, <span class="tok-number">0x0D</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x09</span>, <span class="tok-number">0x01</span> }, .pkcs9_emailAddress },</span>
<span class="line" id="L71">    });</span>
<span class="line" id="L72">};</span>
<span class="line" id="L73"></span>
<span class="line" id="L74"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> NamedCurve = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L75">    secp384r1,</span>
<span class="line" id="L76">    X9_62_prime256v1,</span>
<span class="line" id="L77"></span>
<span class="line" id="L78">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> map = std.ComptimeStringMap(NamedCurve, .{</span>
<span class="line" id="L79">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2B</span>, <span class="tok-number">0x81</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x00</span>, <span class="tok-number">0x22</span> }, .secp384r1 },</span>
<span class="line" id="L80">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x2A</span>, <span class="tok-number">0x86</span>, <span class="tok-number">0x48</span>, <span class="tok-number">0xCE</span>, <span class="tok-number">0x3D</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x07</span> }, .X9_62_prime256v1 },</span>
<span class="line" id="L81">    });</span>
<span class="line" id="L82">};</span>
<span class="line" id="L83"></span>
<span class="line" id="L84"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExtensionId = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L85">    subject_key_identifier,</span>
<span class="line" id="L86">    key_usage,</span>
<span class="line" id="L87">    private_key_usage_period,</span>
<span class="line" id="L88">    subject_alt_name,</span>
<span class="line" id="L89">    issuer_alt_name,</span>
<span class="line" id="L90">    basic_constraints,</span>
<span class="line" id="L91">    crl_number,</span>
<span class="line" id="L92">    certificate_policies,</span>
<span class="line" id="L93">    authority_key_identifier,</span>
<span class="line" id="L94"></span>
<span class="line" id="L95">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> map = std.ComptimeStringMap(ExtensionId, .{</span>
<span class="line" id="L96">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x1D</span>, <span class="tok-number">0x0E</span> }, .subject_key_identifier },</span>
<span class="line" id="L97">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x1D</span>, <span class="tok-number">0x0F</span> }, .key_usage },</span>
<span class="line" id="L98">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x1D</span>, <span class="tok-number">0x10</span> }, .private_key_usage_period },</span>
<span class="line" id="L99">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x1D</span>, <span class="tok-number">0x11</span> }, .subject_alt_name },</span>
<span class="line" id="L100">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x1D</span>, <span class="tok-number">0x12</span> }, .issuer_alt_name },</span>
<span class="line" id="L101">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x1D</span>, <span class="tok-number">0x13</span> }, .basic_constraints },</span>
<span class="line" id="L102">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x1D</span>, <span class="tok-number">0x14</span> }, .crl_number },</span>
<span class="line" id="L103">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x1D</span>, <span class="tok-number">0x20</span> }, .certificate_policies },</span>
<span class="line" id="L104">        .{ &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x55</span>, <span class="tok-number">0x1D</span>, <span class="tok-number">0x23</span> }, .authority_key_identifier },</span>
<span class="line" id="L105">    });</span>
<span class="line" id="L106">};</span>
<span class="line" id="L107"></span>
<span class="line" id="L108"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GeneralNameTag = <span class="tok-kw">enum</span>(<span class="tok-type">u5</span>) {</span>
<span class="line" id="L109">    otherName = <span class="tok-number">0</span>,</span>
<span class="line" id="L110">    rfc822Name = <span class="tok-number">1</span>,</span>
<span class="line" id="L111">    dNSName = <span class="tok-number">2</span>,</span>
<span class="line" id="L112">    x400Address = <span class="tok-number">3</span>,</span>
<span class="line" id="L113">    directoryName = <span class="tok-number">4</span>,</span>
<span class="line" id="L114">    ediPartyName = <span class="tok-number">5</span>,</span>
<span class="line" id="L115">    uniformResourceIdentifier = <span class="tok-number">6</span>,</span>
<span class="line" id="L116">    iPAddress = <span class="tok-number">7</span>,</span>
<span class="line" id="L117">    registeredID = <span class="tok-number">8</span>,</span>
<span class="line" id="L118">    _,</span>
<span class="line" id="L119">};</span>
<span class="line" id="L120"></span>
<span class="line" id="L121"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Parsed = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L122">    certificate: Certificate,</span>
<span class="line" id="L123">    issuer_slice: Slice,</span>
<span class="line" id="L124">    subject_slice: Slice,</span>
<span class="line" id="L125">    common_name_slice: Slice,</span>
<span class="line" id="L126">    signature_slice: Slice,</span>
<span class="line" id="L127">    signature_algorithm: Algorithm,</span>
<span class="line" id="L128">    pub_key_algo: PubKeyAlgo,</span>
<span class="line" id="L129">    pub_key_slice: Slice,</span>
<span class="line" id="L130">    message_slice: Slice,</span>
<span class="line" id="L131">    subject_alt_name_slice: Slice,</span>
<span class="line" id="L132">    validity: Validity,</span>
<span class="line" id="L133"></span>
<span class="line" id="L134">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PubKeyAlgo = <span class="tok-kw">union</span>(AlgorithmCategory) {</span>
<span class="line" id="L135">        rsaEncryption: <span class="tok-type">void</span>,</span>
<span class="line" id="L136">        X9_62_id_ecPublicKey: NamedCurve,</span>
<span class="line" id="L137">    };</span>
<span class="line" id="L138"></span>
<span class="line" id="L139">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Validity = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L140">        not_before: <span class="tok-type">u64</span>,</span>
<span class="line" id="L141">        not_after: <span class="tok-type">u64</span>,</span>
<span class="line" id="L142">    };</span>
<span class="line" id="L143"></span>
<span class="line" id="L144">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = der.Element.Slice;</span>
<span class="line" id="L145"></span>
<span class="line" id="L146">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(p: Parsed, s: Slice) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L147">        <span class="tok-kw">return</span> p.certificate.buffer[s.start..s.end];</span>
<span class="line" id="L148">    }</span>
<span class="line" id="L149"></span>
<span class="line" id="L150">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">issuer</span>(p: Parsed) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L151">        <span class="tok-kw">return</span> p.slice(p.issuer_slice);</span>
<span class="line" id="L152">    }</span>
<span class="line" id="L153"></span>
<span class="line" id="L154">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subject</span>(p: Parsed) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L155">        <span class="tok-kw">return</span> p.slice(p.subject_slice);</span>
<span class="line" id="L156">    }</span>
<span class="line" id="L157"></span>
<span class="line" id="L158">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">commonName</span>(p: Parsed) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L159">        <span class="tok-kw">return</span> p.slice(p.common_name_slice);</span>
<span class="line" id="L160">    }</span>
<span class="line" id="L161"></span>
<span class="line" id="L162">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">signature</span>(p: Parsed) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L163">        <span class="tok-kw">return</span> p.slice(p.signature_slice);</span>
<span class="line" id="L164">    }</span>
<span class="line" id="L165"></span>
<span class="line" id="L166">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pubKey</span>(p: Parsed) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L167">        <span class="tok-kw">return</span> p.slice(p.pub_key_slice);</span>
<span class="line" id="L168">    }</span>
<span class="line" id="L169"></span>
<span class="line" id="L170">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pubKeySigAlgo</span>(p: Parsed) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L171">        <span class="tok-kw">return</span> p.slice(p.pub_key_signature_algorithm_slice);</span>
<span class="line" id="L172">    }</span>
<span class="line" id="L173"></span>
<span class="line" id="L174">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">message</span>(p: Parsed) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L175">        <span class="tok-kw">return</span> p.slice(p.message_slice);</span>
<span class="line" id="L176">    }</span>
<span class="line" id="L177"></span>
<span class="line" id="L178">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subjectAltName</span>(p: Parsed) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L179">        <span class="tok-kw">return</span> p.slice(p.subject_alt_name_slice);</span>
<span class="line" id="L180">    }</span>
<span class="line" id="L181"></span>
<span class="line" id="L182">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> VerifyError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L183">        CertificateIssuerMismatch,</span>
<span class="line" id="L184">        CertificateNotYetValid,</span>
<span class="line" id="L185">        CertificateExpired,</span>
<span class="line" id="L186">        CertificateSignatureAlgorithmUnsupported,</span>
<span class="line" id="L187">        CertificateSignatureAlgorithmMismatch,</span>
<span class="line" id="L188">        CertificateFieldHasInvalidLength,</span>
<span class="line" id="L189">        CertificateFieldHasWrongDataType,</span>
<span class="line" id="L190">        CertificatePublicKeyInvalid,</span>
<span class="line" id="L191">        CertificateSignatureInvalidLength,</span>
<span class="line" id="L192">        CertificateSignatureInvalid,</span>
<span class="line" id="L193">        CertificateSignatureUnsupportedBitCount,</span>
<span class="line" id="L194">        CertificateSignatureNamedCurveUnsupported,</span>
<span class="line" id="L195">    };</span>
<span class="line" id="L196"></span>
<span class="line" id="L197">    <span class="tok-comment">/// This function verifies:</span></span>
<span class="line" id="L198">    <span class="tok-comment">///  * That the subject's issuer is indeed the provided issuer.</span></span>
<span class="line" id="L199">    <span class="tok-comment">///  * The time validity of the subject.</span></span>
<span class="line" id="L200">    <span class="tok-comment">///  * The signature.</span></span>
<span class="line" id="L201">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">verify</span>(parsed_subject: Parsed, parsed_issuer: Parsed, now_sec: <span class="tok-type">i64</span>) VerifyError!<span class="tok-type">void</span> {</span>
<span class="line" id="L202">        <span class="tok-comment">// Check that the subject's issuer name matches the issuer's</span>
</span>
<span class="line" id="L203">        <span class="tok-comment">// subject name.</span>
</span>
<span class="line" id="L204">        <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, parsed_subject.issuer(), parsed_issuer.subject())) {</span>
<span class="line" id="L205">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateIssuerMismatch;</span>
<span class="line" id="L206">        }</span>
<span class="line" id="L207"></span>
<span class="line" id="L208">        <span class="tok-kw">if</span> (now_sec &lt; parsed_subject.validity.not_before)</span>
<span class="line" id="L209">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateNotYetValid;</span>
<span class="line" id="L210">        <span class="tok-kw">if</span> (now_sec &gt; parsed_subject.validity.not_after)</span>
<span class="line" id="L211">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateExpired;</span>
<span class="line" id="L212"></span>
<span class="line" id="L213">        <span class="tok-kw">switch</span> (parsed_subject.signature_algorithm) {</span>
<span class="line" id="L214">            <span class="tok-kw">inline</span> .sha1WithRSAEncryption,</span>
<span class="line" id="L215">            .sha224WithRSAEncryption,</span>
<span class="line" id="L216">            .sha256WithRSAEncryption,</span>
<span class="line" id="L217">            .sha384WithRSAEncryption,</span>
<span class="line" id="L218">            .sha512WithRSAEncryption,</span>
<span class="line" id="L219">            =&gt; |algorithm| <span class="tok-kw">return</span> verifyRsa(</span>
<span class="line" id="L220">                algorithm.Hash(),</span>
<span class="line" id="L221">                parsed_subject.message(),</span>
<span class="line" id="L222">                parsed_subject.signature(),</span>
<span class="line" id="L223">                parsed_issuer.pub_key_algo,</span>
<span class="line" id="L224">                parsed_issuer.pubKey(),</span>
<span class="line" id="L225">            ),</span>
<span class="line" id="L226"></span>
<span class="line" id="L227">            <span class="tok-kw">inline</span> .ecdsa_with_SHA224,</span>
<span class="line" id="L228">            .ecdsa_with_SHA256,</span>
<span class="line" id="L229">            .ecdsa_with_SHA384,</span>
<span class="line" id="L230">            .ecdsa_with_SHA512,</span>
<span class="line" id="L231">            =&gt; |algorithm| <span class="tok-kw">return</span> verify_ecdsa(</span>
<span class="line" id="L232">                algorithm.Hash(),</span>
<span class="line" id="L233">                parsed_subject.message(),</span>
<span class="line" id="L234">                parsed_subject.signature(),</span>
<span class="line" id="L235">                parsed_issuer.pub_key_algo,</span>
<span class="line" id="L236">                parsed_issuer.pubKey(),</span>
<span class="line" id="L237">            ),</span>
<span class="line" id="L238">        }</span>
<span class="line" id="L239">    }</span>
<span class="line" id="L240"></span>
<span class="line" id="L241">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> VerifyHostNameError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L242">        CertificateHostMismatch,</span>
<span class="line" id="L243">        CertificateFieldHasInvalidLength,</span>
<span class="line" id="L244">    };</span>
<span class="line" id="L245"></span>
<span class="line" id="L246">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">verifyHostName</span>(parsed_subject: Parsed, host_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) VerifyHostNameError!<span class="tok-type">void</span> {</span>
<span class="line" id="L247">        <span class="tok-comment">// If the Subject Alternative Names extension is present, this is</span>
</span>
<span class="line" id="L248">        <span class="tok-comment">// what to check. Otherwise, only the common name is checked.</span>
</span>
<span class="line" id="L249">        <span class="tok-kw">const</span> subject_alt_name = parsed_subject.subjectAltName();</span>
<span class="line" id="L250">        <span class="tok-kw">if</span> (subject_alt_name.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L251">            <span class="tok-kw">if</span> (checkHostName(host_name, parsed_subject.commonName())) {</span>
<span class="line" id="L252">                <span class="tok-kw">return</span>;</span>
<span class="line" id="L253">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L254">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateHostMismatch;</span>
<span class="line" id="L255">            }</span>
<span class="line" id="L256">        }</span>
<span class="line" id="L257"></span>
<span class="line" id="L258">        <span class="tok-kw">const</span> general_names = <span class="tok-kw">try</span> der.Element.parse(subject_alt_name, <span class="tok-number">0</span>);</span>
<span class="line" id="L259">        <span class="tok-kw">var</span> name_i = general_names.slice.start;</span>
<span class="line" id="L260">        <span class="tok-kw">while</span> (name_i &lt; general_names.slice.end) {</span>
<span class="line" id="L261">            <span class="tok-kw">const</span> general_name = <span class="tok-kw">try</span> der.Element.parse(subject_alt_name, name_i);</span>
<span class="line" id="L262">            name_i = general_name.slice.end;</span>
<span class="line" id="L263">            <span class="tok-kw">switch</span> (<span class="tok-builtin">@intToEnum</span>(GeneralNameTag, <span class="tok-builtin">@enumToInt</span>(general_name.identifier.tag))) {</span>
<span class="line" id="L264">                .dNSName =&gt; {</span>
<span class="line" id="L265">                    <span class="tok-kw">const</span> dns_name = subject_alt_name[general_name.slice.start..general_name.slice.end];</span>
<span class="line" id="L266">                    <span class="tok-kw">if</span> (checkHostName(host_name, dns_name)) <span class="tok-kw">return</span>;</span>
<span class="line" id="L267">                },</span>
<span class="line" id="L268">                <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L269">            }</span>
<span class="line" id="L270">        }</span>
<span class="line" id="L271"></span>
<span class="line" id="L272">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateHostMismatch;</span>
<span class="line" id="L273">    }</span>
<span class="line" id="L274"></span>
<span class="line" id="L275">    <span class="tok-kw">fn</span> <span class="tok-fn">checkHostName</span>(host_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, dns_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L276">        <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, dns_name, host_name)) {</span>
<span class="line" id="L277">            <span class="tok-kw">return</span> <span class="tok-null">true</span>; <span class="tok-comment">// exact match</span>
</span>
<span class="line" id="L278">        }</span>
<span class="line" id="L279"></span>
<span class="line" id="L280">        <span class="tok-kw">if</span> (mem.startsWith(<span class="tok-type">u8</span>, dns_name, <span class="tok-str">&quot;*.&quot;</span>)) {</span>
<span class="line" id="L281">            <span class="tok-comment">// wildcard certificate, matches any subdomain</span>
</span>
<span class="line" id="L282">            <span class="tok-comment">// TODO: I think wildcards are not supposed to match any prefix but</span>
</span>
<span class="line" id="L283">            <span class="tok-comment">// only match exactly one subdomain.</span>
</span>
<span class="line" id="L284">            <span class="tok-kw">if</span> (mem.endsWith(<span class="tok-type">u8</span>, host_name, dns_name[<span class="tok-number">1</span>..])) {</span>
<span class="line" id="L285">                <span class="tok-comment">// The host_name has a subdomain, but the important part matches.</span>
</span>
<span class="line" id="L286">                <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L287">            }</span>
<span class="line" id="L288">            <span class="tok-kw">if</span> (mem.eql(<span class="tok-type">u8</span>, dns_name[<span class="tok-number">2</span>..], host_name)) {</span>
<span class="line" id="L289">                <span class="tok-comment">// The host_name has no subdomain and matches exactly.</span>
</span>
<span class="line" id="L290">                <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L291">            }</span>
<span class="line" id="L292">        }</span>
<span class="line" id="L293"></span>
<span class="line" id="L294">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L295">    }</span>
<span class="line" id="L296">};</span>
<span class="line" id="L297"></span>
<span class="line" id="L298"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(cert: Certificate) !Parsed {</span>
<span class="line" id="L299">    <span class="tok-kw">const</span> cert_bytes = cert.buffer;</span>
<span class="line" id="L300">    <span class="tok-kw">const</span> certificate = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, cert.index);</span>
<span class="line" id="L301">    <span class="tok-kw">const</span> tbs_certificate = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, certificate.slice.start);</span>
<span class="line" id="L302">    <span class="tok-kw">const</span> version = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, tbs_certificate.slice.start);</span>
<span class="line" id="L303">    <span class="tok-kw">try</span> checkVersion(cert_bytes, version);</span>
<span class="line" id="L304">    <span class="tok-kw">const</span> serial_number = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, version.slice.end);</span>
<span class="line" id="L305">    <span class="tok-comment">// RFC 5280, section 4.1.2.3:</span>
</span>
<span class="line" id="L306">    <span class="tok-comment">// &quot;This field MUST contain the same algorithm identifier as</span>
</span>
<span class="line" id="L307">    <span class="tok-comment">// the signatureAlgorithm field in the sequence Certificate.&quot;</span>
</span>
<span class="line" id="L308">    <span class="tok-kw">const</span> tbs_signature = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, serial_number.slice.end);</span>
<span class="line" id="L309">    <span class="tok-kw">const</span> issuer = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, tbs_signature.slice.end);</span>
<span class="line" id="L310">    <span class="tok-kw">const</span> validity = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, issuer.slice.end);</span>
<span class="line" id="L311">    <span class="tok-kw">const</span> not_before = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, validity.slice.start);</span>
<span class="line" id="L312">    <span class="tok-kw">const</span> not_before_utc = <span class="tok-kw">try</span> parseTime(cert, not_before);</span>
<span class="line" id="L313">    <span class="tok-kw">const</span> not_after = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, not_before.slice.end);</span>
<span class="line" id="L314">    <span class="tok-kw">const</span> not_after_utc = <span class="tok-kw">try</span> parseTime(cert, not_after);</span>
<span class="line" id="L315">    <span class="tok-kw">const</span> subject = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, validity.slice.end);</span>
<span class="line" id="L316"></span>
<span class="line" id="L317">    <span class="tok-kw">const</span> pub_key_info = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, subject.slice.end);</span>
<span class="line" id="L318">    <span class="tok-kw">const</span> pub_key_signature_algorithm = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, pub_key_info.slice.start);</span>
<span class="line" id="L319">    <span class="tok-kw">const</span> pub_key_algo_elem = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, pub_key_signature_algorithm.slice.start);</span>
<span class="line" id="L320">    <span class="tok-kw">const</span> pub_key_algo_tag = <span class="tok-kw">try</span> parseAlgorithmCategory(cert_bytes, pub_key_algo_elem);</span>
<span class="line" id="L321">    <span class="tok-kw">var</span> pub_key_algo: Parsed.PubKeyAlgo = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L322">    <span class="tok-kw">switch</span> (pub_key_algo_tag) {</span>
<span class="line" id="L323">        .rsaEncryption =&gt; {</span>
<span class="line" id="L324">            pub_key_algo = .{ .rsaEncryption = {} };</span>
<span class="line" id="L325">        },</span>
<span class="line" id="L326">        .X9_62_id_ecPublicKey =&gt; {</span>
<span class="line" id="L327">            <span class="tok-comment">// RFC 5480 Section 2.1.1.1 Named Curve</span>
</span>
<span class="line" id="L328">            <span class="tok-comment">// ECParameters ::= CHOICE {</span>
</span>
<span class="line" id="L329">            <span class="tok-comment">//   namedCurve         OBJECT IDENTIFIER</span>
</span>
<span class="line" id="L330">            <span class="tok-comment">//   -- implicitCurve   NULL</span>
</span>
<span class="line" id="L331">            <span class="tok-comment">//   -- specifiedCurve  SpecifiedECDomain</span>
</span>
<span class="line" id="L332">            <span class="tok-comment">// }</span>
</span>
<span class="line" id="L333">            <span class="tok-kw">const</span> params_elem = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, pub_key_algo_elem.slice.end);</span>
<span class="line" id="L334">            <span class="tok-kw">const</span> named_curve = <span class="tok-kw">try</span> parseNamedCurve(cert_bytes, params_elem);</span>
<span class="line" id="L335">            pub_key_algo = .{ .X9_62_id_ecPublicKey = named_curve };</span>
<span class="line" id="L336">        },</span>
<span class="line" id="L337">    }</span>
<span class="line" id="L338">    <span class="tok-kw">const</span> pub_key_elem = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, pub_key_signature_algorithm.slice.end);</span>
<span class="line" id="L339">    <span class="tok-kw">const</span> pub_key = <span class="tok-kw">try</span> parseBitString(cert, pub_key_elem);</span>
<span class="line" id="L340"></span>
<span class="line" id="L341">    <span class="tok-kw">var</span> common_name = der.Element.Slice.empty;</span>
<span class="line" id="L342">    <span class="tok-kw">var</span> name_i = subject.slice.start;</span>
<span class="line" id="L343">    <span class="tok-kw">while</span> (name_i &lt; subject.slice.end) {</span>
<span class="line" id="L344">        <span class="tok-kw">const</span> rdn = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, name_i);</span>
<span class="line" id="L345">        <span class="tok-kw">var</span> rdn_i = rdn.slice.start;</span>
<span class="line" id="L346">        <span class="tok-kw">while</span> (rdn_i &lt; rdn.slice.end) {</span>
<span class="line" id="L347">            <span class="tok-kw">const</span> atav = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, rdn_i);</span>
<span class="line" id="L348">            <span class="tok-kw">var</span> atav_i = atav.slice.start;</span>
<span class="line" id="L349">            <span class="tok-kw">while</span> (atav_i &lt; atav.slice.end) {</span>
<span class="line" id="L350">                <span class="tok-kw">const</span> ty_elem = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, atav_i);</span>
<span class="line" id="L351">                <span class="tok-kw">const</span> ty = <span class="tok-kw">try</span> parseAttribute(cert_bytes, ty_elem);</span>
<span class="line" id="L352">                <span class="tok-kw">const</span> val = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, ty_elem.slice.end);</span>
<span class="line" id="L353">                <span class="tok-kw">switch</span> (ty) {</span>
<span class="line" id="L354">                    .commonName =&gt; common_name = val.slice,</span>
<span class="line" id="L355">                    <span class="tok-kw">else</span> =&gt; {},</span>
<span class="line" id="L356">                }</span>
<span class="line" id="L357">                atav_i = val.slice.end;</span>
<span class="line" id="L358">            }</span>
<span class="line" id="L359">            rdn_i = atav.slice.end;</span>
<span class="line" id="L360">        }</span>
<span class="line" id="L361">        name_i = rdn.slice.end;</span>
<span class="line" id="L362">    }</span>
<span class="line" id="L363"></span>
<span class="line" id="L364">    <span class="tok-kw">const</span> sig_algo = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, tbs_certificate.slice.end);</span>
<span class="line" id="L365">    <span class="tok-kw">const</span> algo_elem = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, sig_algo.slice.start);</span>
<span class="line" id="L366">    <span class="tok-kw">const</span> signature_algorithm = <span class="tok-kw">try</span> parseAlgorithm(cert_bytes, algo_elem);</span>
<span class="line" id="L367">    <span class="tok-kw">const</span> sig_elem = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, sig_algo.slice.end);</span>
<span class="line" id="L368">    <span class="tok-kw">const</span> signature = <span class="tok-kw">try</span> parseBitString(cert, sig_elem);</span>
<span class="line" id="L369"></span>
<span class="line" id="L370">    <span class="tok-comment">// Extensions</span>
</span>
<span class="line" id="L371">    <span class="tok-kw">var</span> subject_alt_name_slice = der.Element.Slice.empty;</span>
<span class="line" id="L372">    ext: {</span>
<span class="line" id="L373">        <span class="tok-kw">if</span> (pub_key_info.slice.end &gt;= tbs_certificate.slice.end)</span>
<span class="line" id="L374">            <span class="tok-kw">break</span> :ext;</span>
<span class="line" id="L375"></span>
<span class="line" id="L376">        <span class="tok-kw">const</span> outer_extensions = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, pub_key_info.slice.end);</span>
<span class="line" id="L377">        <span class="tok-kw">if</span> (outer_extensions.identifier.tag != .bitstring)</span>
<span class="line" id="L378">            <span class="tok-kw">break</span> :ext;</span>
<span class="line" id="L379"></span>
<span class="line" id="L380">        <span class="tok-kw">const</span> extensions = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, outer_extensions.slice.start);</span>
<span class="line" id="L381"></span>
<span class="line" id="L382">        <span class="tok-kw">var</span> ext_i = extensions.slice.start;</span>
<span class="line" id="L383">        <span class="tok-kw">while</span> (ext_i &lt; extensions.slice.end) {</span>
<span class="line" id="L384">            <span class="tok-kw">const</span> extension = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, ext_i);</span>
<span class="line" id="L385">            ext_i = extension.slice.end;</span>
<span class="line" id="L386">            <span class="tok-kw">const</span> oid_elem = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, extension.slice.start);</span>
<span class="line" id="L387">            <span class="tok-kw">const</span> ext_id = parseExtensionId(cert_bytes, oid_elem) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L388">                <span class="tok-kw">error</span>.CertificateHasUnrecognizedObjectId =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L389">                <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L390">            };</span>
<span class="line" id="L391">            <span class="tok-kw">const</span> critical_elem = <span class="tok-kw">try</span> der.Element.parse(cert_bytes, oid_elem.slice.end);</span>
<span class="line" id="L392">            <span class="tok-kw">const</span> ext_bytes_elem = <span class="tok-kw">if</span> (critical_elem.identifier.tag != .boolean)</span>
<span class="line" id="L393">                critical_elem</span>
<span class="line" id="L394">            <span class="tok-kw">else</span></span>
<span class="line" id="L395">                <span class="tok-kw">try</span> der.Element.parse(cert_bytes, critical_elem.slice.end);</span>
<span class="line" id="L396">            <span class="tok-kw">switch</span> (ext_id) {</span>
<span class="line" id="L397">                .subject_alt_name =&gt; subject_alt_name_slice = ext_bytes_elem.slice,</span>
<span class="line" id="L398">                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L399">            }</span>
<span class="line" id="L400">        }</span>
<span class="line" id="L401">    }</span>
<span class="line" id="L402"></span>
<span class="line" id="L403">    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L404">        .certificate = cert,</span>
<span class="line" id="L405">        .common_name_slice = common_name,</span>
<span class="line" id="L406">        .issuer_slice = issuer.slice,</span>
<span class="line" id="L407">        .subject_slice = subject.slice,</span>
<span class="line" id="L408">        .signature_slice = signature,</span>
<span class="line" id="L409">        .signature_algorithm = signature_algorithm,</span>
<span class="line" id="L410">        .message_slice = .{ .start = certificate.slice.start, .end = tbs_certificate.slice.end },</span>
<span class="line" id="L411">        .pub_key_algo = pub_key_algo,</span>
<span class="line" id="L412">        .pub_key_slice = pub_key,</span>
<span class="line" id="L413">        .validity = .{</span>
<span class="line" id="L414">            .not_before = not_before_utc,</span>
<span class="line" id="L415">            .not_after = not_after_utc,</span>
<span class="line" id="L416">        },</span>
<span class="line" id="L417">        .subject_alt_name_slice = subject_alt_name_slice,</span>
<span class="line" id="L418">    };</span>
<span class="line" id="L419">}</span>
<span class="line" id="L420"></span>
<span class="line" id="L421"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">verify</span>(subject: Certificate, issuer: Certificate, now_sec: <span class="tok-type">i64</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L422">    <span class="tok-kw">const</span> parsed_subject = <span class="tok-kw">try</span> subject.parse();</span>
<span class="line" id="L423">    <span class="tok-kw">const</span> parsed_issuer = <span class="tok-kw">try</span> issuer.parse();</span>
<span class="line" id="L424">    <span class="tok-kw">return</span> parsed_subject.verify(parsed_issuer, now_sec);</span>
<span class="line" id="L425">}</span>
<span class="line" id="L426"></span>
<span class="line" id="L427"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contents</span>(cert: Certificate, elem: der.Element) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L428">    <span class="tok-kw">return</span> cert.buffer[elem.slice.start..elem.slice.end];</span>
<span class="line" id="L429">}</span>
<span class="line" id="L430"></span>
<span class="line" id="L431"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseBitString</span>(cert: Certificate, elem: der.Element) !der.Element.Slice {</span>
<span class="line" id="L432">    <span class="tok-kw">if</span> (elem.identifier.tag != .bitstring) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateFieldHasWrongDataType;</span>
<span class="line" id="L433">    <span class="tok-kw">if</span> (cert.buffer[elem.slice.start] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateHasInvalidBitString;</span>
<span class="line" id="L434">    <span class="tok-kw">return</span> .{ .start = elem.slice.start + <span class="tok-number">1</span>, .end = elem.slice.end };</span>
<span class="line" id="L435">}</span>
<span class="line" id="L436"></span>
<span class="line" id="L437"><span class="tok-comment">/// Returns number of seconds since epoch.</span></span>
<span class="line" id="L438"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseTime</span>(cert: Certificate, elem: der.Element) !<span class="tok-type">u64</span> {</span>
<span class="line" id="L439">    <span class="tok-kw">const</span> bytes = cert.contents(elem);</span>
<span class="line" id="L440">    <span class="tok-kw">switch</span> (elem.identifier.tag) {</span>
<span class="line" id="L441">        .utc_time =&gt; {</span>
<span class="line" id="L442">            <span class="tok-comment">// Example: &quot;YYMMDD000000Z&quot;</span>
</span>
<span class="line" id="L443">            <span class="tok-kw">if</span> (bytes.len != <span class="tok-number">13</span>)</span>
<span class="line" id="L444">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateTimeInvalid;</span>
<span class="line" id="L445">            <span class="tok-kw">if</span> (bytes[<span class="tok-number">12</span>] != <span class="tok-str">'Z'</span>)</span>
<span class="line" id="L446">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateTimeInvalid;</span>
<span class="line" id="L447"></span>
<span class="line" id="L448">            <span class="tok-kw">return</span> Date.toSeconds(.{</span>
<span class="line" id="L449">                .year = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">2000</span>) + <span class="tok-kw">try</span> parseTimeDigits(bytes[<span class="tok-number">0</span>..<span class="tok-number">2</span>].*, <span class="tok-number">0</span>, <span class="tok-number">99</span>),</span>
<span class="line" id="L450">                .month = <span class="tok-kw">try</span> parseTimeDigits(bytes[<span class="tok-number">2</span>..<span class="tok-number">4</span>].*, <span class="tok-number">1</span>, <span class="tok-number">12</span>),</span>
<span class="line" id="L451">                .day = <span class="tok-kw">try</span> parseTimeDigits(bytes[<span class="tok-number">4</span>..<span class="tok-number">6</span>].*, <span class="tok-number">1</span>, <span class="tok-number">31</span>),</span>
<span class="line" id="L452">                .hour = <span class="tok-kw">try</span> parseTimeDigits(bytes[<span class="tok-number">6</span>..<span class="tok-number">8</span>].*, <span class="tok-number">0</span>, <span class="tok-number">23</span>),</span>
<span class="line" id="L453">                .minute = <span class="tok-kw">try</span> parseTimeDigits(bytes[<span class="tok-number">8</span>..<span class="tok-number">10</span>].*, <span class="tok-number">0</span>, <span class="tok-number">59</span>),</span>
<span class="line" id="L454">                .second = <span class="tok-kw">try</span> parseTimeDigits(bytes[<span class="tok-number">10</span>..<span class="tok-number">12</span>].*, <span class="tok-number">0</span>, <span class="tok-number">59</span>),</span>
<span class="line" id="L455">            });</span>
<span class="line" id="L456">        },</span>
<span class="line" id="L457">        .generalized_time =&gt; {</span>
<span class="line" id="L458">            <span class="tok-comment">// Examples:</span>
</span>
<span class="line" id="L459">            <span class="tok-comment">// &quot;19920521000000Z&quot;</span>
</span>
<span class="line" id="L460">            <span class="tok-comment">// &quot;19920622123421Z&quot;</span>
</span>
<span class="line" id="L461">            <span class="tok-comment">// &quot;19920722132100.3Z&quot;</span>
</span>
<span class="line" id="L462">            <span class="tok-kw">if</span> (bytes.len &lt; <span class="tok-number">15</span>)</span>
<span class="line" id="L463">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateTimeInvalid;</span>
<span class="line" id="L464">            <span class="tok-kw">return</span> Date.toSeconds(.{</span>
<span class="line" id="L465">                .year = <span class="tok-kw">try</span> parseYear4(bytes[<span class="tok-number">0</span>..<span class="tok-number">4</span>]),</span>
<span class="line" id="L466">                .month = <span class="tok-kw">try</span> parseTimeDigits(bytes[<span class="tok-number">4</span>..<span class="tok-number">6</span>].*, <span class="tok-number">1</span>, <span class="tok-number">12</span>),</span>
<span class="line" id="L467">                .day = <span class="tok-kw">try</span> parseTimeDigits(bytes[<span class="tok-number">6</span>..<span class="tok-number">8</span>].*, <span class="tok-number">1</span>, <span class="tok-number">31</span>),</span>
<span class="line" id="L468">                .hour = <span class="tok-kw">try</span> parseTimeDigits(bytes[<span class="tok-number">8</span>..<span class="tok-number">10</span>].*, <span class="tok-number">0</span>, <span class="tok-number">23</span>),</span>
<span class="line" id="L469">                .minute = <span class="tok-kw">try</span> parseTimeDigits(bytes[<span class="tok-number">10</span>..<span class="tok-number">12</span>].*, <span class="tok-number">0</span>, <span class="tok-number">59</span>),</span>
<span class="line" id="L470">                .second = <span class="tok-kw">try</span> parseTimeDigits(bytes[<span class="tok-number">12</span>..<span class="tok-number">14</span>].*, <span class="tok-number">0</span>, <span class="tok-number">59</span>),</span>
<span class="line" id="L471">            });</span>
<span class="line" id="L472">        },</span>
<span class="line" id="L473">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateFieldHasWrongDataType,</span>
<span class="line" id="L474">    }</span>
<span class="line" id="L475">}</span>
<span class="line" id="L476"></span>
<span class="line" id="L477"><span class="tok-kw">const</span> Date = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L478">    <span class="tok-comment">/// example: 1999</span></span>
<span class="line" id="L479">    year: <span class="tok-type">u16</span>,</span>
<span class="line" id="L480">    <span class="tok-comment">/// range: 1 to 12</span></span>
<span class="line" id="L481">    month: <span class="tok-type">u8</span>,</span>
<span class="line" id="L482">    <span class="tok-comment">/// range: 1 to 31</span></span>
<span class="line" id="L483">    day: <span class="tok-type">u8</span>,</span>
<span class="line" id="L484">    <span class="tok-comment">/// range: 0 to 59</span></span>
<span class="line" id="L485">    hour: <span class="tok-type">u8</span>,</span>
<span class="line" id="L486">    <span class="tok-comment">/// range: 0 to 59</span></span>
<span class="line" id="L487">    minute: <span class="tok-type">u8</span>,</span>
<span class="line" id="L488">    <span class="tok-comment">/// range: 0 to 59</span></span>
<span class="line" id="L489">    second: <span class="tok-type">u8</span>,</span>
<span class="line" id="L490"></span>
<span class="line" id="L491">    <span class="tok-comment">/// Convert to number of seconds since epoch.</span></span>
<span class="line" id="L492">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toSeconds</span>(date: Date) <span class="tok-type">u64</span> {</span>
<span class="line" id="L493">        <span class="tok-kw">var</span> sec: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L494"></span>
<span class="line" id="L495">        {</span>
<span class="line" id="L496">            <span class="tok-kw">var</span> year: <span class="tok-type">u16</span> = <span class="tok-number">1970</span>;</span>
<span class="line" id="L497">            <span class="tok-kw">while</span> (year &lt; date.year) : (year += <span class="tok-number">1</span>) {</span>
<span class="line" id="L498">                <span class="tok-kw">const</span> days: <span class="tok-type">u64</span> = std.time.epoch.getDaysInYear(year);</span>
<span class="line" id="L499">                sec += days * std.time.epoch.secs_per_day;</span>
<span class="line" id="L500">            }</span>
<span class="line" id="L501">        }</span>
<span class="line" id="L502"></span>
<span class="line" id="L503">        {</span>
<span class="line" id="L504">            <span class="tok-kw">const</span> is_leap = std.time.epoch.isLeapYear(date.year);</span>
<span class="line" id="L505">            <span class="tok-kw">var</span> month: <span class="tok-type">u4</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L506">            <span class="tok-kw">while</span> (month &lt; date.month) : (month += <span class="tok-number">1</span>) {</span>
<span class="line" id="L507">                <span class="tok-kw">const</span> days: <span class="tok-type">u64</span> = std.time.epoch.getDaysInMonth(</span>
<span class="line" id="L508">                    <span class="tok-builtin">@intToEnum</span>(std.time.epoch.YearLeapKind, <span class="tok-builtin">@boolToInt</span>(is_leap)),</span>
<span class="line" id="L509">                    <span class="tok-builtin">@intToEnum</span>(std.time.epoch.Month, month),</span>
<span class="line" id="L510">                );</span>
<span class="line" id="L511">                sec += days * std.time.epoch.secs_per_day;</span>
<span class="line" id="L512">            }</span>
<span class="line" id="L513">        }</span>
<span class="line" id="L514"></span>
<span class="line" id="L515">        sec += (date.day - <span class="tok-number">1</span>) * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, std.time.epoch.secs_per_day);</span>
<span class="line" id="L516">        sec += date.hour * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">60</span> * <span class="tok-number">60</span>);</span>
<span class="line" id="L517">        sec += date.minute * <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">60</span>);</span>
<span class="line" id="L518">        sec += date.second;</span>
<span class="line" id="L519"></span>
<span class="line" id="L520">        <span class="tok-kw">return</span> sec;</span>
<span class="line" id="L521">    }</span>
<span class="line" id="L522">};</span>
<span class="line" id="L523"></span>
<span class="line" id="L524"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseTimeDigits</span>(nn: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>), min: <span class="tok-type">u8</span>, max: <span class="tok-type">u8</span>) !<span class="tok-type">u8</span> {</span>
<span class="line" id="L525">    <span class="tok-kw">const</span> zero: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>) = .{ <span class="tok-str">'0'</span>, <span class="tok-str">'0'</span> };</span>
<span class="line" id="L526">    <span class="tok-kw">const</span> mm: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u8</span>) = .{ <span class="tok-number">10</span>, <span class="tok-number">1</span> };</span>
<span class="line" id="L527">    <span class="tok-kw">const</span> result = <span class="tok-builtin">@reduce</span>(.Add, (nn -% zero) *% mm);</span>
<span class="line" id="L528">    <span class="tok-kw">if</span> (result &lt; min) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateTimeInvalid;</span>
<span class="line" id="L529">    <span class="tok-kw">if</span> (result &gt; max) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateTimeInvalid;</span>
<span class="line" id="L530">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L531">}</span>
<span class="line" id="L532"></span>
<span class="line" id="L533"><span class="tok-kw">test</span> parseTimeDigits {</span>
<span class="line" id="L534">    <span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;</span>
<span class="line" id="L535">    <span class="tok-kw">try</span> expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), <span class="tok-kw">try</span> parseTimeDigits(<span class="tok-str">&quot;00&quot;</span>.*, <span class="tok-number">0</span>, <span class="tok-number">99</span>));</span>
<span class="line" id="L536">    <span class="tok-kw">try</span> expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">99</span>), <span class="tok-kw">try</span> parseTimeDigits(<span class="tok-str">&quot;99&quot;</span>.*, <span class="tok-number">0</span>, <span class="tok-number">99</span>));</span>
<span class="line" id="L537">    <span class="tok-kw">try</span> expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">42</span>), <span class="tok-kw">try</span> parseTimeDigits(<span class="tok-str">&quot;42&quot;</span>.*, <span class="tok-number">0</span>, <span class="tok-number">99</span>));</span>
<span class="line" id="L538"></span>
<span class="line" id="L539">    <span class="tok-kw">const</span> expectError = std.testing.expectError;</span>
<span class="line" id="L540">    <span class="tok-kw">try</span> expectError(<span class="tok-kw">error</span>.CertificateTimeInvalid, parseTimeDigits(<span class="tok-str">&quot;13&quot;</span>.*, <span class="tok-number">1</span>, <span class="tok-number">12</span>));</span>
<span class="line" id="L541">    <span class="tok-kw">try</span> expectError(<span class="tok-kw">error</span>.CertificateTimeInvalid, parseTimeDigits(<span class="tok-str">&quot;00&quot;</span>.*, <span class="tok-number">1</span>, <span class="tok-number">12</span>));</span>
<span class="line" id="L542">}</span>
<span class="line" id="L543"></span>
<span class="line" id="L544"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseYear4</span>(text: *<span class="tok-kw">const</span> [<span class="tok-number">4</span>]<span class="tok-type">u8</span>) !<span class="tok-type">u16</span> {</span>
<span class="line" id="L545">    <span class="tok-kw">const</span> nnnn: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">u16</span>) = .{ text[<span class="tok-number">0</span>], text[<span class="tok-number">1</span>], text[<span class="tok-number">2</span>], text[<span class="tok-number">3</span>] };</span>
<span class="line" id="L546">    <span class="tok-kw">const</span> zero: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">u16</span>) = .{ <span class="tok-str">'0'</span>, <span class="tok-str">'0'</span>, <span class="tok-str">'0'</span>, <span class="tok-str">'0'</span> };</span>
<span class="line" id="L547">    <span class="tok-kw">const</span> mmmm: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">u16</span>) = .{ <span class="tok-number">1000</span>, <span class="tok-number">100</span>, <span class="tok-number">10</span>, <span class="tok-number">1</span> };</span>
<span class="line" id="L548">    <span class="tok-kw">const</span> result = <span class="tok-builtin">@reduce</span>(.Add, (nnnn -% zero) *% mmmm);</span>
<span class="line" id="L549">    <span class="tok-kw">if</span> (result &gt; <span class="tok-number">9999</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateTimeInvalid;</span>
<span class="line" id="L550">    <span class="tok-kw">return</span> result;</span>
<span class="line" id="L551">}</span>
<span class="line" id="L552"></span>
<span class="line" id="L553"><span class="tok-kw">test</span> parseYear4 {</span>
<span class="line" id="L554">    <span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;</span>
<span class="line" id="L555">    <span class="tok-kw">try</span> expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">0</span>), <span class="tok-kw">try</span> parseYear4(<span class="tok-str">&quot;0000&quot;</span>));</span>
<span class="line" id="L556">    <span class="tok-kw">try</span> expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">9999</span>), <span class="tok-kw">try</span> parseYear4(<span class="tok-str">&quot;9999&quot;</span>));</span>
<span class="line" id="L557">    <span class="tok-kw">try</span> expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">1988</span>), <span class="tok-kw">try</span> parseYear4(<span class="tok-str">&quot;1988&quot;</span>));</span>
<span class="line" id="L558"></span>
<span class="line" id="L559">    <span class="tok-kw">const</span> expectError = std.testing.expectError;</span>
<span class="line" id="L560">    <span class="tok-kw">try</span> expectError(<span class="tok-kw">error</span>.CertificateTimeInvalid, parseYear4(<span class="tok-str">&quot;999b&quot;</span>));</span>
<span class="line" id="L561">    <span class="tok-kw">try</span> expectError(<span class="tok-kw">error</span>.CertificateTimeInvalid, parseYear4(<span class="tok-str">&quot;crap&quot;</span>));</span>
<span class="line" id="L562">}</span>
<span class="line" id="L563"></span>
<span class="line" id="L564"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseAlgorithm</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, element: der.Element) !Algorithm {</span>
<span class="line" id="L565">    <span class="tok-kw">return</span> parseEnum(Algorithm, bytes, element);</span>
<span class="line" id="L566">}</span>
<span class="line" id="L567"></span>
<span class="line" id="L568"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseAlgorithmCategory</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, element: der.Element) !AlgorithmCategory {</span>
<span class="line" id="L569">    <span class="tok-kw">return</span> parseEnum(AlgorithmCategory, bytes, element);</span>
<span class="line" id="L570">}</span>
<span class="line" id="L571"></span>
<span class="line" id="L572"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseAttribute</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, element: der.Element) !Attribute {</span>
<span class="line" id="L573">    <span class="tok-kw">return</span> parseEnum(Attribute, bytes, element);</span>
<span class="line" id="L574">}</span>
<span class="line" id="L575"></span>
<span class="line" id="L576"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseNamedCurve</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, element: der.Element) !NamedCurve {</span>
<span class="line" id="L577">    <span class="tok-kw">return</span> parseEnum(NamedCurve, bytes, element);</span>
<span class="line" id="L578">}</span>
<span class="line" id="L579"></span>
<span class="line" id="L580"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseExtensionId</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, element: der.Element) !ExtensionId {</span>
<span class="line" id="L581">    <span class="tok-kw">return</span> parseEnum(ExtensionId, bytes, element);</span>
<span class="line" id="L582">}</span>
<span class="line" id="L583"></span>
<span class="line" id="L584"><span class="tok-kw">fn</span> <span class="tok-fn">parseEnum</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, element: der.Element) !E {</span>
<span class="line" id="L585">    <span class="tok-kw">if</span> (element.identifier.tag != .object_identifier)</span>
<span class="line" id="L586">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateFieldHasWrongDataType;</span>
<span class="line" id="L587">    <span class="tok-kw">const</span> oid_bytes = bytes[element.slice.start..element.slice.end];</span>
<span class="line" id="L588">    <span class="tok-kw">return</span> E.map.get(oid_bytes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateHasUnrecognizedObjectId;</span>
<span class="line" id="L589">}</span>
<span class="line" id="L590"></span>
<span class="line" id="L591"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkVersion</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, version: der.Element) !<span class="tok-type">void</span> {</span>
<span class="line" id="L592">    <span class="tok-kw">if</span> (<span class="tok-builtin">@bitCast</span>(<span class="tok-type">u8</span>, version.identifier) != <span class="tok-number">0xa0</span> <span class="tok-kw">or</span></span>
<span class="line" id="L593">        !mem.eql(<span class="tok-type">u8</span>, bytes[version.slice.start..version.slice.end], <span class="tok-str">&quot;\x02\x01\x02&quot;</span>))</span>
<span class="line" id="L594">    {</span>
<span class="line" id="L595">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnsupportedCertificateVersion;</span>
<span class="line" id="L596">    }</span>
<span class="line" id="L597">}</span>
<span class="line" id="L598"></span>
<span class="line" id="L599"><span class="tok-kw">fn</span> <span class="tok-fn">verifyRsa</span>(</span>
<span class="line" id="L600">    <span class="tok-kw">comptime</span> Hash: <span class="tok-type">type</span>,</span>
<span class="line" id="L601">    message: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L602">    sig: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L603">    pub_key_algo: Parsed.PubKeyAlgo,</span>
<span class="line" id="L604">    pub_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L605">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L606">    <span class="tok-kw">if</span> (pub_key_algo != .rsaEncryption) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureAlgorithmMismatch;</span>
<span class="line" id="L607">    <span class="tok-kw">const</span> pk_components = <span class="tok-kw">try</span> rsa.PublicKey.parseDer(pub_key);</span>
<span class="line" id="L608">    <span class="tok-kw">const</span> exponent = pk_components.exponent;</span>
<span class="line" id="L609">    <span class="tok-kw">const</span> modulus = pk_components.modulus;</span>
<span class="line" id="L610">    <span class="tok-kw">if</span> (exponent.len &gt; modulus.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificatePublicKeyInvalid;</span>
<span class="line" id="L611">    <span class="tok-kw">if</span> (sig.len != modulus.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureInvalidLength;</span>
<span class="line" id="L612"></span>
<span class="line" id="L613">    <span class="tok-kw">const</span> hash_der = <span class="tok-kw">switch</span> (Hash) {</span>
<span class="line" id="L614">        crypto.hash.Sha1 =&gt; [_]<span class="tok-type">u8</span>{</span>
<span class="line" id="L615">            <span class="tok-number">0x30</span>, <span class="tok-number">0x21</span>, <span class="tok-number">0x30</span>, <span class="tok-number">0x09</span>, <span class="tok-number">0x06</span>, <span class="tok-number">0x05</span>, <span class="tok-number">0x2b</span>, <span class="tok-number">0x0e</span>,</span>
<span class="line" id="L616">            <span class="tok-number">0x03</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0x1a</span>, <span class="tok-number">0x05</span>, <span class="tok-number">0x00</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x14</span>,</span>
<span class="line" id="L617">        },</span>
<span class="line" id="L618">        crypto.hash.sha2.Sha224 =&gt; [_]<span class="tok-type">u8</span>{</span>
<span class="line" id="L619">            <span class="tok-number">0x30</span>, <span class="tok-number">0x2d</span>, <span class="tok-number">0x30</span>, <span class="tok-number">0x0d</span>, <span class="tok-number">0x06</span>, <span class="tok-number">0x09</span>, <span class="tok-number">0x60</span>, <span class="tok-number">0x86</span>,</span>
<span class="line" id="L620">            <span class="tok-number">0x48</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x65</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x05</span>,</span>
<span class="line" id="L621">            <span class="tok-number">0x00</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x1c</span>,</span>
<span class="line" id="L622">        },</span>
<span class="line" id="L623">        crypto.hash.sha2.Sha256 =&gt; [_]<span class="tok-type">u8</span>{</span>
<span class="line" id="L624">            <span class="tok-number">0x30</span>, <span class="tok-number">0x31</span>, <span class="tok-number">0x30</span>, <span class="tok-number">0x0d</span>, <span class="tok-number">0x06</span>, <span class="tok-number">0x09</span>, <span class="tok-number">0x60</span>, <span class="tok-number">0x86</span>,</span>
<span class="line" id="L625">            <span class="tok-number">0x48</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x65</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x05</span>,</span>
<span class="line" id="L626">            <span class="tok-number">0x00</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x20</span>,</span>
<span class="line" id="L627">        },</span>
<span class="line" id="L628">        crypto.hash.sha2.Sha384 =&gt; [_]<span class="tok-type">u8</span>{</span>
<span class="line" id="L629">            <span class="tok-number">0x30</span>, <span class="tok-number">0x41</span>, <span class="tok-number">0x30</span>, <span class="tok-number">0x0d</span>, <span class="tok-number">0x06</span>, <span class="tok-number">0x09</span>, <span class="tok-number">0x60</span>, <span class="tok-number">0x86</span>,</span>
<span class="line" id="L630">            <span class="tok-number">0x48</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x65</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0x05</span>,</span>
<span class="line" id="L631">            <span class="tok-number">0x00</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x30</span>,</span>
<span class="line" id="L632">        },</span>
<span class="line" id="L633">        crypto.hash.sha2.Sha512 =&gt; [_]<span class="tok-type">u8</span>{</span>
<span class="line" id="L634">            <span class="tok-number">0x30</span>, <span class="tok-number">0x51</span>, <span class="tok-number">0x30</span>, <span class="tok-number">0x0d</span>, <span class="tok-number">0x06</span>, <span class="tok-number">0x09</span>, <span class="tok-number">0x60</span>, <span class="tok-number">0x86</span>,</span>
<span class="line" id="L635">            <span class="tok-number">0x48</span>, <span class="tok-number">0x01</span>, <span class="tok-number">0x65</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x05</span>,</span>
<span class="line" id="L636">            <span class="tok-number">0x00</span>, <span class="tok-number">0x04</span>, <span class="tok-number">0x40</span>,</span>
<span class="line" id="L637">        },</span>
<span class="line" id="L638">        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unreachable&quot;</span>),</span>
<span class="line" id="L639">    };</span>
<span class="line" id="L640"></span>
<span class="line" id="L641">    <span class="tok-kw">var</span> msg_hashed: [Hash.digest_length]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L642">    Hash.hash(message, &amp;msg_hashed, .{});</span>
<span class="line" id="L643"></span>
<span class="line" id="L644">    <span class="tok-kw">var</span> rsa_mem_buf: [<span class="tok-number">512</span> * <span class="tok-number">64</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L645">    <span class="tok-kw">var</span> fba = std.heap.FixedBufferAllocator.init(&amp;rsa_mem_buf);</span>
<span class="line" id="L646">    <span class="tok-kw">const</span> ally = fba.allocator();</span>
<span class="line" id="L647"></span>
<span class="line" id="L648">    <span class="tok-kw">switch</span> (modulus.len) {</span>
<span class="line" id="L649">        <span class="tok-kw">inline</span> <span class="tok-number">128</span>, <span class="tok-number">256</span>, <span class="tok-number">512</span> =&gt; |modulus_len| {</span>
<span class="line" id="L650">            <span class="tok-kw">const</span> ps_len = modulus_len - (hash_der.len + msg_hashed.len) - <span class="tok-number">3</span>;</span>
<span class="line" id="L651">            <span class="tok-kw">const</span> em: [modulus_len]<span class="tok-type">u8</span> =</span>
<span class="line" id="L652">                [<span class="tok-number">2</span>]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span> } ++</span>
<span class="line" id="L653">                ([<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0xff</span>} ** ps_len) ++</span>
<span class="line" id="L654">                [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ++</span>
<span class="line" id="L655">                hash_der ++</span>
<span class="line" id="L656">                msg_hashed;</span>
<span class="line" id="L657"></span>
<span class="line" id="L658">            <span class="tok-kw">const</span> public_key = rsa.PublicKey.fromBytes(exponent, modulus, ally) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L659">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// rsa_mem_buf is big enough</span>
</span>
<span class="line" id="L660">            };</span>
<span class="line" id="L661">            <span class="tok-kw">const</span> em_dec = rsa.encrypt(modulus_len, sig[<span class="tok-number">0</span>..modulus_len].*, public_key, ally) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L662">                <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-comment">// rsa_mem_buf is big enough</span>
</span>
<span class="line" id="L663"></span>
<span class="line" id="L664">                <span class="tok-kw">error</span>.MessageTooLong =&gt; <span class="tok-kw">unreachable</span>,</span>
<span class="line" id="L665">                <span class="tok-kw">error</span>.NegativeIntoUnsigned =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO make RSA not emit this error&quot;</span>),</span>
<span class="line" id="L666">                <span class="tok-kw">error</span>.TargetTooSmall =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO make RSA not emit this error&quot;</span>),</span>
<span class="line" id="L667">                <span class="tok-kw">error</span>.BufferTooSmall =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO make RSA not emit this error&quot;</span>),</span>
<span class="line" id="L668">            };</span>
<span class="line" id="L669"></span>
<span class="line" id="L670">            <span class="tok-kw">if</span> (!mem.eql(<span class="tok-type">u8</span>, &amp;em, &amp;em_dec)) {</span>
<span class="line" id="L671">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureInvalid;</span>
<span class="line" id="L672">            }</span>
<span class="line" id="L673">        },</span>
<span class="line" id="L674">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L675">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureUnsupportedBitCount;</span>
<span class="line" id="L676">        },</span>
<span class="line" id="L677">    }</span>
<span class="line" id="L678">}</span>
<span class="line" id="L679"></span>
<span class="line" id="L680"><span class="tok-kw">fn</span> <span class="tok-fn">verify_ecdsa</span>(</span>
<span class="line" id="L681">    <span class="tok-kw">comptime</span> Hash: <span class="tok-type">type</span>,</span>
<span class="line" id="L682">    message: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L683">    encoded_sig: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L684">    pub_key_algo: Parsed.PubKeyAlgo,</span>
<span class="line" id="L685">    sec1_pub_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L686">) !<span class="tok-type">void</span> {</span>
<span class="line" id="L687">    <span class="tok-kw">const</span> sig_named_curve = <span class="tok-kw">switch</span> (pub_key_algo) {</span>
<span class="line" id="L688">        .X9_62_id_ecPublicKey =&gt; |named_curve| named_curve,</span>
<span class="line" id="L689">        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureAlgorithmMismatch,</span>
<span class="line" id="L690">    };</span>
<span class="line" id="L691"></span>
<span class="line" id="L692">    <span class="tok-kw">switch</span> (sig_named_curve) {</span>
<span class="line" id="L693">        .secp384r1 =&gt; {</span>
<span class="line" id="L694">            <span class="tok-kw">const</span> P = crypto.ecc.P384;</span>
<span class="line" id="L695">            <span class="tok-kw">const</span> Ecdsa = crypto.sign.ecdsa.Ecdsa(P, Hash);</span>
<span class="line" id="L696">            <span class="tok-kw">const</span> sig = Ecdsa.Signature.fromDer(encoded_sig) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L697">                <span class="tok-kw">error</span>.InvalidEncoding =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureInvalid,</span>
<span class="line" id="L698">            };</span>
<span class="line" id="L699">            <span class="tok-kw">const</span> pub_key = Ecdsa.PublicKey.fromSec1(sec1_pub_key) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L700">                <span class="tok-kw">error</span>.InvalidEncoding =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureInvalid,</span>
<span class="line" id="L701">                <span class="tok-kw">error</span>.NonCanonical =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureInvalid,</span>
<span class="line" id="L702">                <span class="tok-kw">error</span>.NotSquare =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureInvalid,</span>
<span class="line" id="L703">            };</span>
<span class="line" id="L704">            sig.verify(message, pub_key) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L705">                <span class="tok-kw">error</span>.IdentityElement =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureInvalid,</span>
<span class="line" id="L706">                <span class="tok-kw">error</span>.NonCanonical =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureInvalid,</span>
<span class="line" id="L707">                <span class="tok-kw">error</span>.SignatureVerificationFailed =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureInvalid,</span>
<span class="line" id="L708">            };</span>
<span class="line" id="L709">        },</span>
<span class="line" id="L710">        .X9_62_prime256v1 =&gt; {</span>
<span class="line" id="L711">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateSignatureNamedCurveUnsupported;</span>
<span class="line" id="L712">        },</span>
<span class="line" id="L713">    }</span>
<span class="line" id="L714">}</span>
<span class="line" id="L715"></span>
<span class="line" id="L716"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);</span>
<span class="line" id="L717"><span class="tok-kw">const</span> crypto = std.crypto;</span>
<span class="line" id="L718"><span class="tok-kw">const</span> mem = std.mem;</span>
<span class="line" id="L719"><span class="tok-kw">const</span> Certificate = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L720"></span>
<span class="line" id="L721"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> der = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L722">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Class = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {</span>
<span class="line" id="L723">        universal,</span>
<span class="line" id="L724">        application,</span>
<span class="line" id="L725">        context_specific,</span>
<span class="line" id="L726">        private,</span>
<span class="line" id="L727">    };</span>
<span class="line" id="L728"></span>
<span class="line" id="L729">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PC = <span class="tok-kw">enum</span>(<span class="tok-type">u1</span>) {</span>
<span class="line" id="L730">        primitive,</span>
<span class="line" id="L731">        constructed,</span>
<span class="line" id="L732">    };</span>
<span class="line" id="L733"></span>
<span class="line" id="L734">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Identifier = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u8</span>) {</span>
<span class="line" id="L735">        tag: Tag,</span>
<span class="line" id="L736">        pc: PC,</span>
<span class="line" id="L737">        class: Class,</span>
<span class="line" id="L738">    };</span>
<span class="line" id="L739"></span>
<span class="line" id="L740">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span>(<span class="tok-type">u5</span>) {</span>
<span class="line" id="L741">        boolean = <span class="tok-number">1</span>,</span>
<span class="line" id="L742">        integer = <span class="tok-number">2</span>,</span>
<span class="line" id="L743">        bitstring = <span class="tok-number">3</span>,</span>
<span class="line" id="L744">        octetstring = <span class="tok-number">4</span>,</span>
<span class="line" id="L745">        <span class="tok-null">null</span> = <span class="tok-number">5</span>,</span>
<span class="line" id="L746">        object_identifier = <span class="tok-number">6</span>,</span>
<span class="line" id="L747">        sequence = <span class="tok-number">16</span>,</span>
<span class="line" id="L748">        sequence_of = <span class="tok-number">17</span>,</span>
<span class="line" id="L749">        utc_time = <span class="tok-number">23</span>,</span>
<span class="line" id="L750">        generalized_time = <span class="tok-number">24</span>,</span>
<span class="line" id="L751">        _,</span>
<span class="line" id="L752">    };</span>
<span class="line" id="L753"></span>
<span class="line" id="L754">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Element = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L755">        identifier: Identifier,</span>
<span class="line" id="L756">        slice: Slice,</span>
<span class="line" id="L757"></span>
<span class="line" id="L758">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Slice = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L759">            start: <span class="tok-type">u32</span>,</span>
<span class="line" id="L760">            end: <span class="tok-type">u32</span>,</span>
<span class="line" id="L761"></span>
<span class="line" id="L762">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: Slice = .{ .start = <span class="tok-number">0</span>, .end = <span class="tok-number">0</span> };</span>
<span class="line" id="L763">        };</span>
<span class="line" id="L764"></span>
<span class="line" id="L765">        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParseError = <span class="tok-kw">error</span>{CertificateFieldHasInvalidLength};</span>
<span class="line" id="L766"></span>
<span class="line" id="L767">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, index: <span class="tok-type">u32</span>) ParseError!Element {</span>
<span class="line" id="L768">            <span class="tok-kw">var</span> i = index;</span>
<span class="line" id="L769">            <span class="tok-kw">const</span> identifier = <span class="tok-builtin">@bitCast</span>(Identifier, bytes[i]);</span>
<span class="line" id="L770">            i += <span class="tok-number">1</span>;</span>
<span class="line" id="L771">            <span class="tok-kw">const</span> size_byte = bytes[i];</span>
<span class="line" id="L772">            i += <span class="tok-number">1</span>;</span>
<span class="line" id="L773">            <span class="tok-kw">if</span> ((size_byte &gt;&gt; <span class="tok-number">7</span>) == <span class="tok-number">0</span>) {</span>
<span class="line" id="L774">                <span class="tok-kw">return</span> .{</span>
<span class="line" id="L775">                    .identifier = identifier,</span>
<span class="line" id="L776">                    .slice = .{</span>
<span class="line" id="L777">                        .start = i,</span>
<span class="line" id="L778">                        .end = i + size_byte,</span>
<span class="line" id="L779">                    },</span>
<span class="line" id="L780">                };</span>
<span class="line" id="L781">            }</span>
<span class="line" id="L782"></span>
<span class="line" id="L783">            <span class="tok-kw">const</span> len_size = <span class="tok-builtin">@truncate</span>(<span class="tok-type">u7</span>, size_byte);</span>
<span class="line" id="L784">            <span class="tok-kw">if</span> (len_size &gt; <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u32</span>)) {</span>
<span class="line" id="L785">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateFieldHasInvalidLength;</span>
<span class="line" id="L786">            }</span>
<span class="line" id="L787"></span>
<span class="line" id="L788">            <span class="tok-kw">const</span> end_i = i + len_size;</span>
<span class="line" id="L789">            <span class="tok-kw">var</span> long_form_size: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L790">            <span class="tok-kw">while</span> (i &lt; end_i) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L791">                long_form_size = (long_form_size &lt;&lt; <span class="tok-number">8</span>) | bytes[i];</span>
<span class="line" id="L792">            }</span>
<span class="line" id="L793"></span>
<span class="line" id="L794">            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L795">                .identifier = identifier,</span>
<span class="line" id="L796">                .slice = .{</span>
<span class="line" id="L797">                    .start = i,</span>
<span class="line" id="L798">                    .end = i + long_form_size,</span>
<span class="line" id="L799">                },</span>
<span class="line" id="L800">            };</span>
<span class="line" id="L801">        }</span>
<span class="line" id="L802">    };</span>
<span class="line" id="L803">};</span>
<span class="line" id="L804"></span>
<span class="line" id="L805"><span class="tok-kw">test</span> {</span>
<span class="line" id="L806">    _ = Bundle;</span>
<span class="line" id="L807">}</span>
<span class="line" id="L808"></span>
<span class="line" id="L809"><span class="tok-comment">/// TODO: replace this with Frank's upcoming RSA implementation. the verify</span></span>
<span class="line" id="L810"><span class="tok-comment">/// function won't have the possibility of failure - it will either identify a</span></span>
<span class="line" id="L811"><span class="tok-comment">/// valid signature or an invalid signature.</span></span>
<span class="line" id="L812"><span class="tok-comment">/// This code is borrowed from https://github.com/shiguredo/tls13-zig</span></span>
<span class="line" id="L813"><span class="tok-comment">/// which is licensed under the Apache License Version 2.0, January 2004</span></span>
<span class="line" id="L814"><span class="tok-comment">/// http://www.apache.org/licenses/</span></span>
<span class="line" id="L815"><span class="tok-comment">/// The code has been modified.</span></span>
<span class="line" id="L816"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> rsa = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L817">    <span class="tok-kw">const</span> BigInt = std.math.big.int.Managed;</span>
<span class="line" id="L818"></span>
<span class="line" id="L819">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PSSSignature = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L820">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromBytes</span>(<span class="tok-kw">comptime</span> modulus_len: <span class="tok-type">usize</span>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) [modulus_len]<span class="tok-type">u8</span> {</span>
<span class="line" id="L821">            <span class="tok-kw">var</span> result = [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** modulus_len;</span>
<span class="line" id="L822">            std.mem.copy(<span class="tok-type">u8</span>, &amp;result, msg);</span>
<span class="line" id="L823">            <span class="tok-kw">return</span> result;</span>
<span class="line" id="L824">        }</span>
<span class="line" id="L825"></span>
<span class="line" id="L826">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">verify</span>(<span class="tok-kw">comptime</span> modulus_len: <span class="tok-type">usize</span>, sig: [modulus_len]<span class="tok-type">u8</span>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, public_key: PublicKey, <span class="tok-kw">comptime</span> Hash: <span class="tok-type">type</span>, allocator: std.mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L827">            <span class="tok-kw">const</span> mod_bits = <span class="tok-kw">try</span> countBits(public_key.n.toConst(), allocator);</span>
<span class="line" id="L828">            <span class="tok-kw">const</span> em_dec = <span class="tok-kw">try</span> encrypt(modulus_len, sig, public_key, allocator);</span>
<span class="line" id="L829"></span>
<span class="line" id="L830">            <span class="tok-kw">try</span> EMSA_PSS_VERIFY(msg, &amp;em_dec, mod_bits - <span class="tok-number">1</span>, Hash.digest_length, Hash, allocator);</span>
<span class="line" id="L831">        }</span>
<span class="line" id="L832"></span>
<span class="line" id="L833">        <span class="tok-kw">fn</span> <span class="tok-fn">EMSA_PSS_VERIFY</span>(msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, em: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, emBit: <span class="tok-type">usize</span>, sLen: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> Hash: <span class="tok-type">type</span>, allocator: std.mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L834">            <span class="tok-comment">// TODO</span>
</span>
<span class="line" id="L835">            <span class="tok-comment">// 1.   If the length of M is greater than the input limitation for</span>
</span>
<span class="line" id="L836">            <span class="tok-comment">//      the hash function (2^61 - 1 octets for SHA-1), output</span>
</span>
<span class="line" id="L837">            <span class="tok-comment">//      &quot;inconsistent&quot; and stop.</span>
</span>
<span class="line" id="L838"></span>
<span class="line" id="L839">            <span class="tok-comment">// emLen = \ceil(emBits/8)</span>
</span>
<span class="line" id="L840">            <span class="tok-kw">const</span> emLen = ((emBit - <span class="tok-number">1</span>) / <span class="tok-number">8</span>) + <span class="tok-number">1</span>;</span>
<span class="line" id="L841">            std.debug.assert(emLen == em.len);</span>
<span class="line" id="L842"></span>
<span class="line" id="L843">            <span class="tok-comment">// 2.   Let mHash = Hash(M), an octet string of length hLen.</span>
</span>
<span class="line" id="L844">            <span class="tok-kw">var</span> mHash: [Hash.digest_length]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L845">            Hash.hash(msg, &amp;mHash, .{});</span>
<span class="line" id="L846"></span>
<span class="line" id="L847">            <span class="tok-comment">// 3.   If emLen &lt; hLen + sLen + 2, output &quot;inconsistent&quot; and stop.</span>
</span>
<span class="line" id="L848">            <span class="tok-kw">if</span> (emLen &lt; Hash.digest_length + sLen + <span class="tok-number">2</span>) {</span>
<span class="line" id="L849">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSignature;</span>
<span class="line" id="L850">            }</span>
<span class="line" id="L851"></span>
<span class="line" id="L852">            <span class="tok-comment">// 4.   If the rightmost octet of EM does not have hexadecimal value</span>
</span>
<span class="line" id="L853">            <span class="tok-comment">//      0xbc, output &quot;inconsistent&quot; and stop.</span>
</span>
<span class="line" id="L854">            <span class="tok-kw">if</span> (em[em.len - <span class="tok-number">1</span>] != <span class="tok-number">0xbc</span>) {</span>
<span class="line" id="L855">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSignature;</span>
<span class="line" id="L856">            }</span>
<span class="line" id="L857"></span>
<span class="line" id="L858">            <span class="tok-comment">// 5.   Let maskedDB be the leftmost emLen - hLen - 1 octets of EM,</span>
</span>
<span class="line" id="L859">            <span class="tok-comment">//      and let H be the next hLen octets.</span>
</span>
<span class="line" id="L860">            <span class="tok-kw">const</span> maskedDB = em[<span class="tok-number">0</span>..(emLen - Hash.digest_length - <span class="tok-number">1</span>)];</span>
<span class="line" id="L861">            <span class="tok-kw">const</span> h = em[(emLen - Hash.digest_length - <span class="tok-number">1</span>)..(emLen - <span class="tok-number">1</span>)];</span>
<span class="line" id="L862"></span>
<span class="line" id="L863">            <span class="tok-comment">// 6.   If the leftmost 8emLen - emBits bits of the leftmost octet in</span>
</span>
<span class="line" id="L864">            <span class="tok-comment">//      maskedDB are not all equal to zero, output &quot;inconsistent&quot; and</span>
</span>
<span class="line" id="L865">            <span class="tok-comment">//      stop.</span>
</span>
<span class="line" id="L866">            <span class="tok-kw">const</span> zero_bits = emLen * <span class="tok-number">8</span> - emBit;</span>
<span class="line" id="L867">            <span class="tok-kw">var</span> mask: <span class="tok-type">u8</span> = maskedDB[<span class="tok-number">0</span>];</span>
<span class="line" id="L868">            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L869">            <span class="tok-kw">while</span> (i &lt; <span class="tok-number">8</span> - zero_bits) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L870">                mask = mask &gt;&gt; <span class="tok-number">1</span>;</span>
<span class="line" id="L871">            }</span>
<span class="line" id="L872">            <span class="tok-kw">if</span> (mask != <span class="tok-number">0</span>) {</span>
<span class="line" id="L873">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSignature;</span>
<span class="line" id="L874">            }</span>
<span class="line" id="L875"></span>
<span class="line" id="L876">            <span class="tok-comment">// 7.   Let dbMask = MGF(H, emLen - hLen - 1).</span>
</span>
<span class="line" id="L877">            <span class="tok-kw">const</span> mgf_len = emLen - Hash.digest_length - <span class="tok-number">1</span>;</span>
<span class="line" id="L878">            <span class="tok-kw">var</span> mgf_out = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, ((mgf_len - <span class="tok-number">1</span>) / Hash.digest_length + <span class="tok-number">1</span>) * Hash.digest_length);</span>
<span class="line" id="L879">            <span class="tok-kw">defer</span> allocator.free(mgf_out);</span>
<span class="line" id="L880">            <span class="tok-kw">var</span> dbMask = <span class="tok-kw">try</span> MGF1(mgf_out, h, mgf_len, Hash, allocator);</span>
<span class="line" id="L881"></span>
<span class="line" id="L882">            <span class="tok-comment">// 8.   Let DB = maskedDB \xor dbMask.</span>
</span>
<span class="line" id="L883">            i = <span class="tok-number">0</span>;</span>
<span class="line" id="L884">            <span class="tok-kw">while</span> (i &lt; dbMask.len) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L885">                dbMask[i] = maskedDB[i] ^ dbMask[i];</span>
<span class="line" id="L886">            }</span>
<span class="line" id="L887"></span>
<span class="line" id="L888">            <span class="tok-comment">// 9.   Set the leftmost 8emLen - emBits bits of the leftmost octet</span>
</span>
<span class="line" id="L889">            <span class="tok-comment">//      in DB to zero.</span>
</span>
<span class="line" id="L890">            i = <span class="tok-number">0</span>;</span>
<span class="line" id="L891">            mask = <span class="tok-number">0</span>;</span>
<span class="line" id="L892">            <span class="tok-kw">while</span> (i &lt; <span class="tok-number">8</span> - zero_bits) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L893">                mask = mask &lt;&lt; <span class="tok-number">1</span>;</span>
<span class="line" id="L894">                mask += <span class="tok-number">1</span>;</span>
<span class="line" id="L895">            }</span>
<span class="line" id="L896">            dbMask[<span class="tok-number">0</span>] = dbMask[<span class="tok-number">0</span>] &amp; mask;</span>
<span class="line" id="L897"></span>
<span class="line" id="L898">            <span class="tok-comment">// 10.  If the emLen - hLen - sLen - 2 leftmost octets of DB are not</span>
</span>
<span class="line" id="L899">            <span class="tok-comment">//      zero or if the octet at position emLen - hLen - sLen - 1 (the</span>
</span>
<span class="line" id="L900">            <span class="tok-comment">//      leftmost position is &quot;position 1&quot;) does not have hexadecimal</span>
</span>
<span class="line" id="L901">            <span class="tok-comment">//      value 0x01, output &quot;inconsistent&quot; and stop.</span>
</span>
<span class="line" id="L902">            <span class="tok-kw">if</span> (dbMask[mgf_len - sLen - <span class="tok-number">2</span>] != <span class="tok-number">0x00</span>) {</span>
<span class="line" id="L903">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSignature;</span>
<span class="line" id="L904">            }</span>
<span class="line" id="L905"></span>
<span class="line" id="L906">            <span class="tok-kw">if</span> (dbMask[mgf_len - sLen - <span class="tok-number">1</span>] != <span class="tok-number">0x01</span>) {</span>
<span class="line" id="L907">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSignature;</span>
<span class="line" id="L908">            }</span>
<span class="line" id="L909"></span>
<span class="line" id="L910">            <span class="tok-comment">// 11.  Let salt be the last sLen octets of DB.</span>
</span>
<span class="line" id="L911">            <span class="tok-kw">const</span> salt = dbMask[(mgf_len - sLen)..];</span>
<span class="line" id="L912"></span>
<span class="line" id="L913">            <span class="tok-comment">// 12.  Let</span>
</span>
<span class="line" id="L914">            <span class="tok-comment">//         M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt ;</span>
</span>
<span class="line" id="L915">            <span class="tok-comment">//      M' is an octet string of length 8 + hLen + sLen with eight</span>
</span>
<span class="line" id="L916">            <span class="tok-comment">//      initial zero octets.</span>
</span>
<span class="line" id="L917">            <span class="tok-kw">var</span> m_p = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, <span class="tok-number">8</span> + Hash.digest_length + sLen);</span>
<span class="line" id="L918">            <span class="tok-kw">defer</span> allocator.free(m_p);</span>
<span class="line" id="L919">            std.mem.copy(<span class="tok-type">u8</span>, m_p, &amp;([_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">8</span>));</span>
<span class="line" id="L920">            std.mem.copy(<span class="tok-type">u8</span>, m_p[<span class="tok-number">8</span>..], &amp;mHash);</span>
<span class="line" id="L921">            std.mem.copy(<span class="tok-type">u8</span>, m_p[(<span class="tok-number">8</span> + Hash.digest_length)..], salt);</span>
<span class="line" id="L922"></span>
<span class="line" id="L923">            <span class="tok-comment">// 13.  Let H' = Hash(M'), an octet string of length hLen.</span>
</span>
<span class="line" id="L924">            <span class="tok-kw">var</span> h_p: [Hash.digest_length]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L925">            Hash.hash(m_p, &amp;h_p, .{});</span>
<span class="line" id="L926"></span>
<span class="line" id="L927">            <span class="tok-comment">// 14.  If H = H', output &quot;consistent&quot;.  Otherwise, output</span>
</span>
<span class="line" id="L928">            <span class="tok-comment">//      &quot;inconsistent&quot;.</span>
</span>
<span class="line" id="L929">            <span class="tok-kw">if</span> (!std.mem.eql(<span class="tok-type">u8</span>, h, &amp;h_p)) {</span>
<span class="line" id="L930">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSignature;</span>
<span class="line" id="L931">            }</span>
<span class="line" id="L932">        }</span>
<span class="line" id="L933"></span>
<span class="line" id="L934">        <span class="tok-kw">fn</span> <span class="tok-fn">MGF1</span>(out: []<span class="tok-type">u8</span>, seed: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, len: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> Hash: <span class="tok-type">type</span>, allocator: std.mem.Allocator) ![]<span class="tok-type">u8</span> {</span>
<span class="line" id="L935">            <span class="tok-kw">var</span> counter: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L936">            <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L937">            <span class="tok-kw">var</span> c: [<span class="tok-number">4</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L938"></span>
<span class="line" id="L939">            <span class="tok-kw">var</span> hash = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, seed.len + c.len);</span>
<span class="line" id="L940">            <span class="tok-kw">defer</span> allocator.free(hash);</span>
<span class="line" id="L941">            std.mem.copy(<span class="tok-type">u8</span>, hash, seed);</span>
<span class="line" id="L942">            <span class="tok-kw">var</span> hashed: [Hash.digest_length]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L943"></span>
<span class="line" id="L944">            <span class="tok-kw">while</span> (idx &lt; len) {</span>
<span class="line" id="L945">                c[<span class="tok-number">0</span>] = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u8</span>, (counter &gt;&gt; <span class="tok-number">24</span>) &amp; <span class="tok-number">0xFF</span>);</span>
<span class="line" id="L946">                c[<span class="tok-number">1</span>] = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u8</span>, (counter &gt;&gt; <span class="tok-number">16</span>) &amp; <span class="tok-number">0xFF</span>);</span>
<span class="line" id="L947">                c[<span class="tok-number">2</span>] = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u8</span>, (counter &gt;&gt; <span class="tok-number">8</span>) &amp; <span class="tok-number">0xFF</span>);</span>
<span class="line" id="L948">                c[<span class="tok-number">3</span>] = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u8</span>, counter &amp; <span class="tok-number">0xFF</span>);</span>
<span class="line" id="L949"></span>
<span class="line" id="L950">                std.mem.copy(<span class="tok-type">u8</span>, hash[seed.len..], &amp;c);</span>
<span class="line" id="L951">                Hash.hash(hash, &amp;hashed, .{});</span>
<span class="line" id="L952"></span>
<span class="line" id="L953">                std.mem.copy(<span class="tok-type">u8</span>, out[idx..], &amp;hashed);</span>
<span class="line" id="L954">                idx += hashed.len;</span>
<span class="line" id="L955"></span>
<span class="line" id="L956">                counter += <span class="tok-number">1</span>;</span>
<span class="line" id="L957">            }</span>
<span class="line" id="L958"></span>
<span class="line" id="L959">            <span class="tok-kw">return</span> out[<span class="tok-number">0</span>..len];</span>
<span class="line" id="L960">        }</span>
<span class="line" id="L961">    };</span>
<span class="line" id="L962"></span>
<span class="line" id="L963">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PublicKey = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L964">        n: BigInt,</span>
<span class="line" id="L965">        e: BigInt,</span>
<span class="line" id="L966"></span>
<span class="line" id="L967">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *PublicKey) <span class="tok-type">void</span> {</span>
<span class="line" id="L968">            self.n.deinit();</span>
<span class="line" id="L969">            self.e.deinit();</span>
<span class="line" id="L970">        }</span>
<span class="line" id="L971"></span>
<span class="line" id="L972">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromBytes</span>(pub_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, modulus_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: std.mem.Allocator) !PublicKey {</span>
<span class="line" id="L973">            <span class="tok-kw">var</span> _n = <span class="tok-kw">try</span> BigInt.init(allocator);</span>
<span class="line" id="L974">            <span class="tok-kw">errdefer</span> _n.deinit();</span>
<span class="line" id="L975">            <span class="tok-kw">try</span> setBytes(&amp;_n, modulus_bytes, allocator);</span>
<span class="line" id="L976"></span>
<span class="line" id="L977">            <span class="tok-kw">var</span> _e = <span class="tok-kw">try</span> BigInt.init(allocator);</span>
<span class="line" id="L978">            <span class="tok-kw">errdefer</span> _e.deinit();</span>
<span class="line" id="L979">            <span class="tok-kw">try</span> setBytes(&amp;_e, pub_bytes, allocator);</span>
<span class="line" id="L980"></span>
<span class="line" id="L981">            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L982">                .n = _n,</span>
<span class="line" id="L983">                .e = _e,</span>
<span class="line" id="L984">            };</span>
<span class="line" id="L985">        }</span>
<span class="line" id="L986"></span>
<span class="line" id="L987">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseDer</span>(pub_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-kw">struct</span> { modulus: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, exponent: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> } {</span>
<span class="line" id="L988">            <span class="tok-kw">const</span> pub_key_seq = <span class="tok-kw">try</span> der.Element.parse(pub_key, <span class="tok-number">0</span>);</span>
<span class="line" id="L989">            <span class="tok-kw">if</span> (pub_key_seq.identifier.tag != .sequence) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateFieldHasWrongDataType;</span>
<span class="line" id="L990">            <span class="tok-kw">const</span> modulus_elem = <span class="tok-kw">try</span> der.Element.parse(pub_key, pub_key_seq.slice.start);</span>
<span class="line" id="L991">            <span class="tok-kw">if</span> (modulus_elem.identifier.tag != .integer) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateFieldHasWrongDataType;</span>
<span class="line" id="L992">            <span class="tok-kw">const</span> exponent_elem = <span class="tok-kw">try</span> der.Element.parse(pub_key, modulus_elem.slice.end);</span>
<span class="line" id="L993">            <span class="tok-kw">if</span> (exponent_elem.identifier.tag != .integer) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CertificateFieldHasWrongDataType;</span>
<span class="line" id="L994">            <span class="tok-comment">// Skip over meaningless zeroes in the modulus.</span>
</span>
<span class="line" id="L995">            <span class="tok-kw">const</span> modulus_raw = pub_key[modulus_elem.slice.start..modulus_elem.slice.end];</span>
<span class="line" id="L996">            <span class="tok-kw">const</span> modulus_offset = <span class="tok-kw">for</span> (modulus_raw) |byte, i| {</span>
<span class="line" id="L997">                <span class="tok-kw">if</span> (byte != <span class="tok-number">0</span>) <span class="tok-kw">break</span> i;</span>
<span class="line" id="L998">            } <span class="tok-kw">else</span> modulus_raw.len;</span>
<span class="line" id="L999">            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L1000">                .modulus = modulus_raw[modulus_offset..],</span>
<span class="line" id="L1001">                .exponent = pub_key[exponent_elem.slice.start..exponent_elem.slice.end],</span>
<span class="line" id="L1002">            };</span>
<span class="line" id="L1003">        }</span>
<span class="line" id="L1004">    };</span>
<span class="line" id="L1005"></span>
<span class="line" id="L1006">    <span class="tok-kw">fn</span> <span class="tok-fn">encrypt</span>(<span class="tok-kw">comptime</span> modulus_len: <span class="tok-type">usize</span>, msg: [modulus_len]<span class="tok-type">u8</span>, public_key: PublicKey, allocator: std.mem.Allocator) ![modulus_len]<span class="tok-type">u8</span> {</span>
<span class="line" id="L1007">        <span class="tok-kw">var</span> m = <span class="tok-kw">try</span> BigInt.init(allocator);</span>
<span class="line" id="L1008">        <span class="tok-kw">defer</span> m.deinit();</span>
<span class="line" id="L1009"></span>
<span class="line" id="L1010">        <span class="tok-kw">try</span> setBytes(&amp;m, &amp;msg, allocator);</span>
<span class="line" id="L1011"></span>
<span class="line" id="L1012">        <span class="tok-kw">if</span> (m.order(public_key.n) != .lt) {</span>
<span class="line" id="L1013">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MessageTooLong;</span>
<span class="line" id="L1014">        }</span>
<span class="line" id="L1015"></span>
<span class="line" id="L1016">        <span class="tok-kw">var</span> e = <span class="tok-kw">try</span> BigInt.init(allocator);</span>
<span class="line" id="L1017">        <span class="tok-kw">defer</span> e.deinit();</span>
<span class="line" id="L1018"></span>
<span class="line" id="L1019">        <span class="tok-kw">try</span> pow_montgomery(&amp;e, &amp;m, &amp;public_key.e, &amp;public_key.n, allocator);</span>
<span class="line" id="L1020"></span>
<span class="line" id="L1021">        <span class="tok-kw">var</span> res: [modulus_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1022"></span>
<span class="line" id="L1023">        <span class="tok-kw">try</span> toBytes(&amp;res, &amp;e, allocator);</span>
<span class="line" id="L1024"></span>
<span class="line" id="L1025">        <span class="tok-kw">return</span> res;</span>
<span class="line" id="L1026">    }</span>
<span class="line" id="L1027"></span>
<span class="line" id="L1028">    <span class="tok-kw">fn</span> <span class="tok-fn">setBytes</span>(r: *BigInt, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allcator: std.mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1029">        <span class="tok-kw">try</span> r.set(<span class="tok-number">0</span>);</span>
<span class="line" id="L1030">        <span class="tok-kw">var</span> tmp = <span class="tok-kw">try</span> BigInt.init(allcator);</span>
<span class="line" id="L1031">        <span class="tok-kw">defer</span> tmp.deinit();</span>
<span class="line" id="L1032">        <span class="tok-kw">for</span> (bytes) |b| {</span>
<span class="line" id="L1033">            <span class="tok-kw">try</span> r.shiftLeft(r, <span class="tok-number">8</span>);</span>
<span class="line" id="L1034">            <span class="tok-kw">try</span> tmp.set(b);</span>
<span class="line" id="L1035">            <span class="tok-kw">try</span> r.add(r, &amp;tmp);</span>
<span class="line" id="L1036">        }</span>
<span class="line" id="L1037">    }</span>
<span class="line" id="L1038"></span>
<span class="line" id="L1039">    <span class="tok-kw">fn</span> <span class="tok-fn">pow_montgomery</span>(r: *BigInt, a: *<span class="tok-kw">const</span> BigInt, x: *<span class="tok-kw">const</span> BigInt, n: *<span class="tok-kw">const</span> BigInt, allocator: std.mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1040">        <span class="tok-kw">var</span> bin_raw: [<span class="tok-number">512</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1041">        <span class="tok-kw">try</span> toBytes(&amp;bin_raw, x, allocator);</span>
<span class="line" id="L1042"></span>
<span class="line" id="L1043">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1044">        <span class="tok-kw">while</span> (bin_raw[i] == <span class="tok-number">0x00</span>) : (i += <span class="tok-number">1</span>) {}</span>
<span class="line" id="L1045">        <span class="tok-kw">const</span> bin = bin_raw[i..];</span>
<span class="line" id="L1046"></span>
<span class="line" id="L1047">        <span class="tok-kw">try</span> r.set(<span class="tok-number">1</span>);</span>
<span class="line" id="L1048">        <span class="tok-kw">var</span> r1 = <span class="tok-kw">try</span> BigInt.init(allocator);</span>
<span class="line" id="L1049">        <span class="tok-kw">defer</span> r1.deinit();</span>
<span class="line" id="L1050">        <span class="tok-kw">try</span> BigInt.copy(&amp;r1, a.toConst());</span>
<span class="line" id="L1051">        i = <span class="tok-number">0</span>;</span>
<span class="line" id="L1052">        <span class="tok-kw">while</span> (i &lt; bin.len * <span class="tok-number">8</span>) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1053">            <span class="tok-kw">if</span> (((bin[i / <span class="tok-number">8</span>] &gt;&gt; <span class="tok-builtin">@intCast</span>(<span class="tok-type">u3</span>, (<span class="tok-number">7</span> - (i % <span class="tok-number">8</span>)))) &amp; <span class="tok-number">0x1</span>) == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1054">                <span class="tok-kw">try</span> BigInt.mul(&amp;r1, r, &amp;r1);</span>
<span class="line" id="L1055">                <span class="tok-kw">try</span> mod(&amp;r1, &amp;r1, n, allocator);</span>
<span class="line" id="L1056">                <span class="tok-kw">try</span> BigInt.sqr(r, r);</span>
<span class="line" id="L1057">                <span class="tok-kw">try</span> mod(r, r, n, allocator);</span>
<span class="line" id="L1058">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1059">                <span class="tok-kw">try</span> BigInt.mul(r, r, &amp;r1);</span>
<span class="line" id="L1060">                <span class="tok-kw">try</span> mod(r, r, n, allocator);</span>
<span class="line" id="L1061">                <span class="tok-kw">try</span> BigInt.sqr(&amp;r1, &amp;r1);</span>
<span class="line" id="L1062">                <span class="tok-kw">try</span> mod(&amp;r1, &amp;r1, n, allocator);</span>
<span class="line" id="L1063">            }</span>
<span class="line" id="L1064">        }</span>
<span class="line" id="L1065">    }</span>
<span class="line" id="L1066"></span>
<span class="line" id="L1067">    <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(out: []<span class="tok-type">u8</span>, a: *<span class="tok-kw">const</span> BigInt, allocator: std.mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1068">        <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{</span>
<span class="line" id="L1069">            BufferTooSmall,</span>
<span class="line" id="L1070">        };</span>
<span class="line" id="L1071"></span>
<span class="line" id="L1072">        <span class="tok-kw">var</span> mask = <span class="tok-kw">try</span> BigInt.initSet(allocator, <span class="tok-number">0xFF</span>);</span>
<span class="line" id="L1073">        <span class="tok-kw">defer</span> mask.deinit();</span>
<span class="line" id="L1074">        <span class="tok-kw">var</span> tmp = <span class="tok-kw">try</span> BigInt.init(allocator);</span>
<span class="line" id="L1075">        <span class="tok-kw">defer</span> tmp.deinit();</span>
<span class="line" id="L1076"></span>
<span class="line" id="L1077">        <span class="tok-kw">var</span> a_copy = <span class="tok-kw">try</span> BigInt.init(allocator);</span>
<span class="line" id="L1078">        <span class="tok-kw">defer</span> a_copy.deinit();</span>
<span class="line" id="L1079">        <span class="tok-kw">try</span> a_copy.copy(a.toConst());</span>
<span class="line" id="L1080"></span>
<span class="line" id="L1081">        <span class="tok-comment">// Encoding into big-endian bytes</span>
</span>
<span class="line" id="L1082">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1083">        <span class="tok-kw">while</span> (i &lt; out.len) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1084">            <span class="tok-kw">try</span> tmp.bitAnd(&amp;a_copy, &amp;mask);</span>
<span class="line" id="L1085">            <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> tmp.to(<span class="tok-type">u8</span>);</span>
<span class="line" id="L1086">            out[out.len - i - <span class="tok-number">1</span>] = b;</span>
<span class="line" id="L1087">            <span class="tok-kw">try</span> a_copy.shiftRight(&amp;a_copy, <span class="tok-number">8</span>);</span>
<span class="line" id="L1088">        }</span>
<span class="line" id="L1089"></span>
<span class="line" id="L1090">        <span class="tok-kw">if</span> (!a_copy.eqZero()) {</span>
<span class="line" id="L1091">            <span class="tok-kw">return</span> Error.BufferTooSmall;</span>
<span class="line" id="L1092">        }</span>
<span class="line" id="L1093">    }</span>
<span class="line" id="L1094"></span>
<span class="line" id="L1095">    <span class="tok-kw">fn</span> <span class="tok-fn">mod</span>(rem: *BigInt, a: *<span class="tok-kw">const</span> BigInt, n: *<span class="tok-kw">const</span> BigInt, allocator: std.mem.Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1096">        <span class="tok-kw">var</span> q = <span class="tok-kw">try</span> BigInt.init(allocator);</span>
<span class="line" id="L1097">        <span class="tok-kw">defer</span> q.deinit();</span>
<span class="line" id="L1098"></span>
<span class="line" id="L1099">        <span class="tok-kw">try</span> BigInt.divFloor(&amp;q, rem, a, n);</span>
<span class="line" id="L1100">    }</span>
<span class="line" id="L1101"></span>
<span class="line" id="L1102">    <span class="tok-kw">fn</span> <span class="tok-fn">countBits</span>(a: std.math.big.int.Const, allocator: std.mem.Allocator) !<span class="tok-type">usize</span> {</span>
<span class="line" id="L1103">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1104">        <span class="tok-kw">var</span> a_copy = <span class="tok-kw">try</span> BigInt.init(allocator);</span>
<span class="line" id="L1105">        <span class="tok-kw">defer</span> a_copy.deinit();</span>
<span class="line" id="L1106">        <span class="tok-kw">try</span> a_copy.copy(a);</span>
<span class="line" id="L1107"></span>
<span class="line" id="L1108">        <span class="tok-kw">while</span> (!a_copy.eqZero()) {</span>
<span class="line" id="L1109">            <span class="tok-kw">try</span> a_copy.shiftRight(&amp;a_copy, <span class="tok-number">1</span>);</span>
<span class="line" id="L1110">            i += <span class="tok-number">1</span>;</span>
<span class="line" id="L1111">        }</span>
<span class="line" id="L1112"></span>
<span class="line" id="L1113">        <span class="tok-kw">return</span> i;</span>
<span class="line" id="L1114">    }</span>
<span class="line" id="L1115">};</span>
<span class="line" id="L1116"></span>
</code></pre></body>
</html>